
<template>
  <form novalidate>
    <div class="row" v-for="(formRow, rowIdx) of formRows" :key="rowIdx">
      <template v-for="(field, fieldIdx) of formRow" :key="rowIdx + '_' + fieldIdx">
        <div class="field">
          <os-label>{{field.label}}</os-label>
          <component :ref="'osField-' + field.name" :is="field.component" v-bind="field"
            v-model="formModel[field.name]" v-os-tooltip.bottom="field.tooltip"
            :form="ctx" @update:model-value="handleInput(field)">
          </component>
          <div v-if="v$.formModel[field.name] && v$.formModel[field.name].$error">
            <os-inline-message>{{errorMessages[field.name]}}</os-inline-message>
          </div>
        </div>
      </template>
    </div>

    <os-divider></os-divider>

    <div class="row">
      <div class="field">
        <slot></slot>
      </div>
    </div>
  </form>
</template>

<script>

import { reactive } from 'vue';
import useVuelidate from '@vuelidate/core'

import alertSvc from '@/common/services/Alerts.js';
import fieldFactory from '@/common/services/FieldFactory.js';
import exprUtil from '@/common/services/ExpressionUtil.js';

export default {
   props: ['schema', 'data'],

   emits: ['input', 'form-validity'],

   setup(props) {
     let ctx = reactive({
       formData: props.data,
       fd: function(name) {
         let object = ctx.formData;
         if (!name) {
           return object;
         }

         let props = name.split('.');
         for (let i = 0; i < props.length; ++i) {
           if (!object) {
             return undefined;
           }
           object = object[props[i]];
         }

         return object;
       }
     });

     return {
       ctx,
       v$: useVuelidate(),
     };
   },

   methods: {
     handleInput: function(field) {
       exprUtil.setValue(this.ctx.formData, field.name, this.formModel[field.name]);
       this.$emit('input', {field: field, data: this.ctx.formData})
       if (this.v$.formModel[field.name]) {
         this.v$.formModel[field.name].$touch();
       }

       this.$emit('form-validity', {invalid: this.v$.$invalid});
     },

     validate: function() {
       this.v$.$touch();

       let invalid = this.v$.$invalid;
       for (let formRow of this.formRows) {
         for (let field of formRow) {
           if (field.type == 'subform') {
             let sf = this.$refs['osField-' + field.name];
             if (!sf.validate()) {
               invalid = true;
             }
           }
         }
       }

       this.$emit('form-validity', {invalid: invalid});
       if (invalid) {
         alertSvc.error('There are validation errors as highlighted below. Please correct them.');
       }

       return !invalid;
     },

     fd: function(name) {
       let object = this.ctx.formData;
       if (!name) {
         return object;
       }

       let props = name.split('.');
       for (let i = 0; i < props.length; ++i) {
         if (!object) {
           return undefined;
         }
         object = object[props[i]];
       }

       return object;
     }
   },

   validations() {
     let fields = [];
     for (let row of this.schema.rows) {
       for (let field of row.fields) {
         fields.push(field);
       }
     }

     return {
       formModel: fieldFactory.getValidationRules(fields)
     }
   },

   computed: {
     formRows: function() {
       let result = [];

       for (let row of this.schema.rows) {
         let formRow = [];

         for (let field of row.fields) {
           if (field.showWhen && !exprUtil.eval(this, field.showWhen)) {
             continue;
           }

           if (!field.component) {
             let component = fieldFactory.getComponent(field.type);
             if (component) {
               field = Object.assign({...field, component: component});
             }
           }

           formRow.push(field);
         }

         if (formRow.length > 0) {
           result.push(formRow);
         }
       }

       return result;
     },

     //
     // TODO: Is this efficient?
     //
     formModel: function() {
       let model = {};
       for (let row of this.schema.rows) {
         for (let field of row.fields) {
           model[field.name] = exprUtil.getValue(this.ctx.formData, field.name);
         }
       }

       return model;
     },

     errorMessages: function() {
       let result = {};

       for (let row of this.schema.rows) {
         for (let field of row.fields) {
           let validators = this.v$.formModel && this.v$.formModel[field.name];
           if (!validators) {
             continue;
           }

           for (let rule in field.validations) {
             if (validators[rule] && validators[rule].$invalid) {
               result[field.name] = field.validations[rule].message;
               break;
             }
           }
         }
       }

       return result;
     }
   },

   watch: {
     data: function(newVal) {
       this.ctx.formData = newVal;
     },

     'ctx.formData': {
       deep: true,

       handler: function(newVal) {
         console.log(newVal);
       }
     }
   }
}

</script>

<style scoped>

form {
  max-width: 80%;
  margin: auto;
}

.row {
  display: flex;
}

.row .field {
  flex: 1 1 0;
  padding: 0.5rem 1rem;
  overflow-x: auto;
}

.row .field :deep(.btn) {
  margin-right: 0.5rem;
}
</style>
